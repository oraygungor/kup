<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interlocking Puzzle Viewer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        .canvas-container {
            position: relative;
            width: 100%;
            height: 400px;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100% !important;
            height: 100% !important;
            display: block;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 p-8">

    <div class="max-w-7xl mx-auto">
        <h1 class="text-4xl md:text-5xl font-bold text-center mb-6">Interlocking Puzzle Viewer</h1>

        <div class="flex items-center justify-center space-x-4 mb-8">
            <span id="solution-counter" class="text-xl">Solution 0 of 0</span>
            <button id="next-button"
                    class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition-all duration-300">
                Next
            </button>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
            <div class="bg-gray-800 p-6 rounded-xl shadow-lg">
                <h2 class="text-2xl font-semibold text-center mb-4">Single Piece</h2>
                <div id="single-piece-container" class="canvas-container rounded-xl overflow-hidden"></div>
            </div>
            <div class="bg-gray-800 p-6 rounded-xl shadow-lg">
                <h2 class="text-2xl font-semibold text-center mb-4">Final Cube</h2>
                <div id="cube-container" class="canvas-container rounded-xl overflow-hidden"></div>
            </div>
        </div>
    </div>
    
    <script>
        // Global variables for the three.js scenes
        let scene1, camera1, renderer1;
        let scene2, camera2, renderer2;
        let singlePieceGroup, puzzleGroup;
        let animationFrameId;

        // Puzzle data and state
        let solutionsData = [];
        let currentSolutionIndex = 0;
        
        // Constants
        const CUBE_SIZE = 1;
        const GAP = 0.15; // Increased gap for better visualization
        const CELL_OFFSET = CUBE_SIZE / 2;
        // Updated color palette for a better visual
        const palette = ['#ff6f61', '#5d9cec', '#5cb85c', '#ffc107', '#9370db', '#87ceeb', '#f08080', '#00ced1'];
        
        // --- UI Elements ---
        const nextButton = document.getElementById('next-button');
        const solutionCounter = document.getElementById('solution-counter');
        const singlePieceContainer = document.getElementById('single-piece-container');
        const cubeContainer = document.getElementById('cube-container');

        // --- Event Listeners ---
        nextButton.addEventListener('click', () => {
            currentSolutionIndex = (currentSolutionIndex + 1) % solutionsData.length;
            displaySolution();
        });

        // --- Three.js Initialization ---
        function initScene(container, N) {
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1f2937);

            const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(N * 1.5, N * 1.5, N * 1.5);
            camera.lookAt(new THREE.Vector3(N / 2, N / 2, N / 2));

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            // New lighting for more volumetric look
            const ambientLight = new THREE.AmbientLight(0x404040); // Soft white ambient light
            scene.add(ambientLight);

            const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x000000, 0.6);
            scene.add(hemisphereLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(N * 2, N * 2, N * 2);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Add camera controls
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            const rotationSpeed = 0.01;

            container.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            container.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;

                const center = new THREE.Vector3(N / 2, N / 2, N / 2);
                const quaternion = new THREE.Quaternion();
                
                const yawAxis = new THREE.Vector3(0, 1, 0);
                quaternion.setFromAxisAngle(yawAxis, -deltaX * rotationSpeed);
                
                const pitchAxis = new THREE.Vector3(1, 0, 0);
                pitchAxis.applyQuaternion(camera.quaternion);
                quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(pitchAxis, -deltaY * rotationSpeed));

                camera.position.sub(center);
                camera.position.applyQuaternion(quaternion);
                camera.position.add(center);
                camera.up.applyQuaternion(quaternion);
                camera.lookAt(center);

                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            container.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            // Touch controls
            let previousTouchPosition = { x: 0, y: 0 };
            container.addEventListener('touchstart', (e) => {
                isDragging = true;
                const touch = e.touches[0];
                previousTouchPosition = { x: touch.clientX, y: touch.clientY };
            });

            container.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const touch = e.touches[0];
                const deltaX = touch.clientX - previousTouchPosition.x;
                const deltaY = touch.clientY - previousTouchPosition.y;

                const center = new THREE.Vector3(N / 2, N / 2, N / 2);
                const quaternion = new THREE.Quaternion();
                
                const yawAxis = new THREE.Vector3(0, 1, 0);
                quaternion.setFromAxisAngle(yawAxis, -deltaX * rotationSpeed);
                
                const pitchAxis = new THREE.Vector3(1, 0, 0);
                pitchAxis.applyQuaternion(camera.quaternion);
                quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(pitchAxis, -deltaY * rotationSpeed));

                camera.position.sub(center);
                camera.position.applyQuaternion(quaternion);
                camera.position.add(center);
                camera.up.applyQuaternion(quaternion);
                camera.lookAt(center);

                previousTouchPosition = { x: touch.clientX, y: touch.clientY };
            });

            container.addEventListener('touchend', () => {
                isDragging = false;
            });

            window.addEventListener('resize', () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });

            return { scene, camera, renderer };
        }

        function init() {
            // Scenes are initialized with a default N value
            const result1 = initScene(singlePieceContainer, 4); 
            scene1 = result1.scene; camera1 = result1.camera; renderer1 = result1.renderer;

            const result2 = initScene(cubeContainer, 4);
            scene2 = result2.scene; camera2 = result2.camera; renderer2 = result2.renderer;

            singlePieceGroup = new THREE.Group();
            scene1.add(singlePieceGroup);

            puzzleGroup = new THREE.Group();
            scene2.add(puzzleGroup);
            
            loadSolutions();
        }

        // --- Visualization Logic ---
        function generateCube(x, y, z, color) {
            const geometry = new THREE.BoxGeometry(CUBE_SIZE - GAP, CUBE_SIZE - GAP, CUBE_SIZE - GAP);
            // Use a different material for a more volumetric feel
            const material = new THREE.MeshStandardMaterial({ color: color, roughness: 0.5, metalness: 0.2 });
            const cube = new THREE.Mesh(geometry, material);
            cube.position.set(x + CELL_OFFSET, y + CELL_OFFSET, z + CELL_OFFSET);
            return cube;
        }

        function drawPiece(piece, group, color) {
            group.clear();
            piece.forEach(([x, y, z]) => {
                group.add(generateCube(x, y, z, color));
            });
        }

        function drawSolution(finalCubePieces, group) {
            group.clear();
            finalCubePieces.forEach((piece, i) => {
                const color = palette[i % palette.length];
                piece.forEach(([x, y, z]) => {
                    group.add(generateCube(x, y, z, color));
                });
            });
        }
        
        async function loadSolutions() {
            try {
                const response = await fetch('cikti.txt');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const text = await response.text();
                solutionsData = parseSolutions(text);

                if (solutionsData.length > 0) {
                    displaySolution();
                } else {
                    solutionCounter.textContent = "No solutions found.";
                    nextButton.disabled = true;
                }
            } catch (error) {
                console.error("Error loading cikti.txt:", error);
                solutionCounter.textContent = "Error loading solutions file.";
                nextButton.disabled = true;
            }
        }

        function parseSolutions(text) {
            const lines = text.trim().split('\n');
            const parsed = [];
            
            lines.forEach(line => {
                try {
                    const data = JSON.parse(line);
                    // Extract the necessary pieces from the JSON data
                    const piece = data.piece;
                    const placements = data.placements;
                    const n = data.n;
                    
                    // We need to parse the `placements` to get a single, combined cube
                    const finalCube = [];
                    placements[0].forEach(cell => finalCube.push(cell));
                    
                    // The number of pieces is `n`
                    const parts = n;

                    parsed.push({
                        n: n,
                        piece: piece,
                        finalCube: placements
                    });
                } catch (e) {
                    console.error("Error parsing JSON line:", e);
                }
            });
            return parsed;
        }


        function displaySolution() {
            if (solutionsData.length === 0) return;

            const solution = solutionsData[currentSolutionIndex];
            const N = solution.n;
            const parts = solution.finalCube.length;
            
            solutionCounter.textContent = `Solution ${currentSolutionIndex + 1} of ${solutionsData.length}`;

            // Update camera perspective based on the new N
            camera1.position.set(N * 1.5, N * 1.5, N * 1.5);
            camera1.lookAt(new THREE.Vector3(N / 2, N / 2, N / 2));
            camera2.position.set(N * 1.5, N * 1.5, N * 1.5);
            camera2.lookAt(new THREE.Vector3(N / 2, N / 2, N / 2));

            // Draw the single piece
            drawPiece(solution.piece, singlePieceGroup, palette[0]);
            
            // Draw all pieces for the final cube in different colors
            drawSolution(solution.finalCube, puzzleGroup);
        }

        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            if (renderer1 && scene1 && camera1) renderer1.render(scene1, camera1);
            if (renderer2 && scene2 && camera2) renderer2.render(scene2, camera2);
        }

        window.onload = function() {
            init();
            animate();
        };

    </script>
</body>
</html>
